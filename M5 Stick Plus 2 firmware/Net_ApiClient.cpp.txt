#include "Net_ApiClient.h"
#include "Net_WiFiManager.h" // For isWifiConnected
#include "Globals.h"
#include "UI.h"
#include "Networking.h" // For SERVER_ADDRESS
#include <HTTPClient.h>
#include <WiFi.h>


// --- ПРОВЕРКА СООБЩЕНИЙ (УЛУЧШЕННАЯ ЛОГИКА) ---
void checkForNewMessages() {
    static unsigned long lastCheck = 0;
    // Увеличим интервал до 5 секунд для большей стабильности
    if (millis() - lastCheck < 5000) { 
        return;
    }
    lastCheck = millis();

    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        String serverUrl = String(SERVER_ADDRESS) + "/message";
        http.begin(serverUrl);
        http.setConnectTimeout(5000); // Увеличим таймаут подключения до 5 секунд
        http.setTimeout(10000);      // Установим общий таймаут запроса на 10 секунд

        int httpResponseCode = http.GET();

        if (httpResponseCode == HTTP_CODE_OK) {
            String payload = http.getString();
            Serial.printf("Received new message: %s\n", payload.c_str());
            receivedMessage = payload;
            newMessageReceived = true;
            messageTimestamp = millis();
            paginateMessage(receivedMessage); 
            displayMenu(); // Немедленно обновляем экран
        } else if (httpResponseCode < 0) { // Логируем все отрицательные коды (ошибки)
             // Добавляем более детальное сообщение об ошибке
             Serial.printf("[HTTP] GET... failed, error: %s\n", http.errorToString(httpResponseCode).c_str());
        }
        
        http.end();
    }
}


// --- ОТПРАВКА ГОЛОСА (НАДЕЖНАЯ ЛОГИКА С 3 ПОПЫТКАМИ) ---
bool sendRecordedVoiceHTTP(uint8_t* audio_buffer, size_t buffer_len) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected. Cannot send voice message.");
        return false;
    }

    HTTPClient http;
    String serverUrl = String(SERVER_ADDRESS) + "/voice";
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        Serial.printf("Attempt %d: Sending voice message (%d bytes) to %s...\n", attempt, buffer_len, serverUrl.c_str());
        
        http.begin(serverUrl);
        http.addHeader("Content-Type", "audio/wav");
        http.setConnectTimeout(5000); // 5 сек на подключение
        http.setTimeout(10000); // 10 сек на всю операцию

        int httpResponseCode = http.POST(audio_buffer, buffer_len);

        if (httpResponseCode == HTTP_CODE_OK) {
            Serial.println("Voice message sent successfully.");
            http.end();
            return true;
        } else {
            Serial.printf("Attempt %d failed. HTTP Error code: %d\n", attempt, httpResponseCode);
            http.end();
            delay(500); // Небольшая задержка перед следующей попыткой
        }
    }

    Serial.println("Failed to send voice message after all attempts.");
    return false;
}

// --- ОТПРАВКА ГОЛОСА В GEMINI И ПОЛУЧЕНИЕ ОТВЕТА ---
bool sendVoiceToGemini(uint8_t* audio_buffer, size_t buffer_len) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected. Cannot send voice to Gemini.");
        receivedMessage = "Error: WiFi not connected.";
        paginateMessage(receivedMessage);
        return false;
    }

    HTTPClient http;
    String serverUrl = String(SERVER_ADDRESS) + "/gemini_voice";
    
    Serial.printf("Sending voice message to Gemini (%d bytes) via %s...\n", buffer_len, serverUrl.c_str());
    
    http.begin(serverUrl);
    http.addHeader("Content-Type", "audio/wav");
    http.setConnectTimeout(10000); // 10 сек на подключение
    http.setTimeout(30000);      // 30 сек на всю операцию, Gemini может думать долго

    int httpResponseCode = http.POST(audio_buffer, buffer_len);

    if (httpResponseCode == HTTP_CODE_OK) {
        String payload = http.getString();
        Serial.printf("Received Gemini response: %s\n", payload.c_str());
        
        receivedMessage = payload;
        // КРИТИЧЕСКИ ВАЖНО: Обновляем контекст только при успехе!
        lastValidGeminiContext = payload; 

        messageTimestamp = millis();
        paginateMessage(receivedMessage); 
        
        http.end();
        return true;
    } else {
        Serial.printf("Gemini request failed. HTTP Error code: %d\n", httpResponseCode);
        String errorPayload = http.getString();
        Serial.printf("Error payload: %s\n", errorPayload.c_str());

        receivedMessage = "Gemini Error: " + String(httpResponseCode) + "\n" + errorPayload;
        // НЕ ОБНОВЛЯЕМ lastValidGeminiContext ПРИ ОШИБКЕ! Контекст остается чистым.
        
        messageTimestamp = millis();
        paginateMessage(receivedMessage);
        
        http.end();
        return false;
    }
}

// --- ОТПРАВКА ГОЛОСА В GOOGLE SEARCH И ПОЛУЧЕНИЕ ОТВЕТА ---
bool sendVoiceToGoogleSearch(uint8_t* audio_buffer, size_t buffer_len) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected. Cannot send voice to Google Search.");
        receivedMessage = "Error: WiFi not connected.";
        paginateMessage(receivedMessage);
        return false;
    }

    HTTPClient http;
    String serverUrl = String(SERVER_ADDRESS) + "/google_search";
    
    Serial.printf("Sending voice message to Google Search (%d bytes) via %s...\n", buffer_len, serverUrl.c_str());
    
    http.begin(serverUrl);
    http.addHeader("Content-Type", "audio/wav");
    http.setConnectTimeout(10000); // 10 сек на подключение
    http.setTimeout(30000);      // 30 сек на всю операцию

    int httpResponseCode = http.POST(audio_buffer, buffer_len);

    if (httpResponseCode == HTTP_CODE_OK) {
        String payload = http.getString();
        Serial.printf("Received Google Search response: %s\n", payload.c_str());
        
        receivedMessage = payload;
        // Обновляем контекст только при успехе
        lastValidGeminiContext = payload; 

        messageTimestamp = millis();
        paginateMessage(receivedMessage); 
        
        http.end();
        return true;
    } else {
        Serial.printf("Google Search request failed. HTTP Error code: %d\n", httpResponseCode);
        String errorPayload = http.getString();
        Serial.printf("Error payload: %s\n", errorPayload.c_str());

        receivedMessage = "Google Search Error: " + String(httpResponseCode) + "\n" + errorPayload;
        // Не засоряем историю ошибкой

        messageTimestamp = millis();
        paginateMessage(receivedMessage);
        
        http.end();
        return false;
    }
}


// --- ОТПРАВКА УТОЧНЯЮЩЕГО ВОПРОСА В GEMINI ---
bool sendFollowUpToGemini(uint8_t* audio_buffer, size_t buffer_len, String ignored_param) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi not connected. Cannot send follow-up to Gemini.");
        receivedMessage = "Error: WiFi not connected.";
        paginateMessage(receivedMessage);
        return false;
    }

    HTTPClient http;
    String serverUrl = String(SERVER_ADDRESS) + "/gemini_followup"; 
    
    Serial.printf("Sending follow-up to Gemini (%d bytes) via %s...\n", buffer_len, serverUrl.c_str());
    
    http.begin(serverUrl);
    http.addHeader("Content-Type", "audio/wav");
    
    // ИСПОЛЬЗУЕМ ТОЛЬКО ВАЛИДНЫЙ КОНТЕКСТ (глобальную переменную), игнорируя параметр, 
    // который мог содержать сообщение об ошибке с экрана.
    http.addHeader("X-Previous-Response", lastValidGeminiContext); 
    
    http.setConnectTimeout(10000);
    http.setTimeout(30000);

    int httpResponseCode = http.POST(audio_buffer, buffer_len);

    if (httpResponseCode == HTTP_CODE_OK) {
        String payload = http.getString();
        Serial.printf("Received Gemini follow-up response: %s\n", payload.c_str());
        
        receivedMessage = payload;
        // Успех - обновляем контекст
        lastValidGeminiContext = payload;

        messageTimestamp = millis();
        paginateMessage(receivedMessage); 
        
        http.end();
        return true;
    } else {
        Serial.printf("Gemini follow-up request failed. HTTP Error code: %d\n", httpResponseCode);
        String errorPayload = http.getString();
        Serial.printf("Error payload: %s\n", errorPayload.c_str());

        receivedMessage = "Gemini Error: " + String(httpResponseCode) + "\n" + errorPayload;
        // Ошибка - контекст НЕ обновляем

        messageTimestamp = millis();
        paginateMessage(receivedMessage);
        
        http.end();
        return false;
    }
}


void handleNetwork() {
    // Only check for messages when in standby to avoid interrupting other modes
    if (isWifiConnected() && menuMode == MODE_MESSAGE_STANDBY) {
        checkForNewMessages();
    }
}