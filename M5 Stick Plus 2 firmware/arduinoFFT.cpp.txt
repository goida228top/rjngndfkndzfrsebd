/*
 * arduinoFFT.cpp
 *
 *  Copyright (c) 2018.  Enrique Albertos
 *
 *  This file is part of arduinoFFT.
 *
 *  arduinoFFT is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  arduinoFFT is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with arduinoFFT.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "arduinoFFT.h"

arduinoFFT::arduinoFFT(void)
{
/* constructor */
}

arduinoFFT::arduinoFFT(double *vReal, double *vImag, uint16_t samples, double samplingFrequency)
{
	this->_vReal = vReal;
	this->_vImag = vImag;
	this->_samples = samples;
	this->_samplingFrequency = samplingFrequency;
}

void arduinoFFT::ComplexToMagnitude(void)
{
	/* vM is half the size of vReal and vImag */
	for (uint16_t i=0; i < this->_samples/2; i++) {
		this->_vReal[i] = sqrt(sq(this->_vReal[i]) + sq(this->_vImag[i]));
	}
}

void arduinoFFT::Compute(fft_direction_t dir)
{
	if(this->_samples <= 4){
		return;
	}
	uint16_t j = 0;
	for (uint16_t i = 0; i < (this->_samples - 1); i++) {
		if (i < j) {
			Swap(&this->_vReal[i], &this->_vReal[j]);
			if(dir==FFT_REVERSE)
				Swap(&this->_vImag[i], &this->_vImag[j]);
		}
		uint16_t k = (this->_samples >> 1);
		while (k <= j) {
			j -= k;
			k >>= 1;
		}
		j += k;
	}
	// Compute the FFT
	double c1 = -1.0;
	double c2 = 0.0;
	uint16_t l2 = 1;
	for (uint8_t l = 0; (l < (uint8_t)log2(this->_samples)); l++) {
		uint16_t l1 = l2;
		l2 <<= 1;
		double u1 = 1.0;
		double u2 = 0.0;
		for (j = 0; j < l1; j++) {
			for (uint16_t i = j; i < this->_samples; i += l2) {
				uint16_t i1 = i + l1;
				double t1 = u1 * this->_vReal[i1] - u2 * this->_vImag[i1];
				double t2 = u1 * this->_vImag[i1] + u2 * this->_vReal[i1];
				this->_vReal[i1] = this->_vReal[i] - t1;
				this->_vImag[i1] = this->_vImag[i] - t2;
				this->_vReal[i] += t1;
				this->_vImag[i] += t2;
			}
			double z = ((u1 * c1) - (u2 * c2));
			u2 = ((u1 * c2) + (u2 * c1));
			u1 = z;
		}
		c2 = sqrt((1.0 - c1) / 2.0);
		if (dir == FFT_FORWARD) {
			c2 = -c2;
		}
		c1 = sqrt((1.0 + c1) / 2.0);
	}
	// Scaling for reverse transform
	if (dir == FFT_REVERSE) {
		for (uint16_t i = 0; i < this->_samples; i++) {
			this->_vReal[i] /= this->_samples;
			this->_vImag[i] /= this->_samples;
		}
	}
}

void arduinoFFT::DCRemoval(void)
{
	double mean = 0;
	for(uint16_t i=1; i < this->_samples; i++)
	{
		mean += this->_vReal[i];
	}
	mean /= this->_samples;
	for(uint16_t i=1; i < this->_samples; i++)
	{
		this->_vReal[i] -= mean;
	}
}

double arduinoFFT::MajorPeak(void)
{
	double maxY = 0;
	uint16_t IndexOfMaxY = 0;
	//If sampling_frequency = 2 * max_frequency in the signal, then the bin width is sampling_frequency / N_samples.
	for (uint16_t i=1; i < this->_samples/2; i++) {
		if ((this->_vReal[i]) > maxY) {
			maxY = this->_vReal[i];
			IndexOfMaxY = i;
		}
	}
	double Peak = (double)IndexOfMaxY * this->_samplingFrequency / (double)this->_samples;
	return(Peak);
}

void arduinoFFT::Reorder(void)
{
	uint16_t j = 0;
	for (uint16_t i = 0; i < (this->_samples - 1); i++) {
		if (i < j) {
			Swap(&this->_vReal[i], &this->_vReal[j]);
		}
		uint16_t k = (this->_samples >> 1);
		while (k <= j) {
			j -= k;
			k >>= 1;
		}
		j += k;
	}
}

void arduinoFFT::Swap(double *x, double *y)
{
	double temp = *x;
	*x = *y;
	*y = temp;
}

void arduinoFFT::Windowing(fft_window_t windowType, fft_direction_t dir)
{
	// Weighing factors are computed once before multiple use of FFT
	// The weighing function is symmetric; half the weighs are recorded
	double samples_m1 = (double)(this->_samples - 1);
	for (uint16_t i=0; i < (this->_samples >> 1); i++) {
		double index_m_first_part = (double)i;
		double index_m_second_part = (double)(this->_samples - 1 - i);
		double ratio_m_first_part = (index_m_first_part / samples_m1);
		double ratio_m_second_part = (index_m_second_part / samples_m1);
		double weigh = 1.0;
		// Choose the proper weighing function
		switch (windowType) {
		case FFT_WIN_TYP_RECTANGLE: // rectangle (Box car)
			weigh = 1.0;
			break;
		case FFT_WIN_TYP_HAMMING: // hamming
			weigh = 0.54 - (0.46 * cos(TWO_PI * ratio_m_first_part));
			break;
		case FFT_WIN_TYP_HANN: // hann
			weigh = 0.54 * (1.0 - cos(TWO_PI * ratio_m_first_part));
			break;
		case FFT_WIN_TYP_TRIANGLE: // triangle (Bartlett)
			weigh = 1.0 - ((2.0 * abs(index_m_first_part - (samples_m1 / 2.0))) / samples_m1);
			break;
		case FFT_WIN_TYP_NUTTALL: // nuttall
			weigh = 0.355768 - (0.487396 * (cos(TWO_PI * ratio_m_first_part))) + (0.144232 * (cos(FOUR_PI * ratio_m_first_part))) - (0.012604 * (cos(SIX_PI * ratio_m_first_part)));
			break;
		case FFT_WIN_TYP_BLACKMAN: // blackman
			weigh = 0.42323 - (0.49755 * (cos(TWO_PI * ratio_m_first_part))) + (0.07922 * (cos(FOUR_PI * ratio_m_first_part)));
			break;
		case FFT_WIN_TYP_BLACKMAN_NUTTALL: // blackman nuttall
			weigh = 0.3635819 - (0.4891775 * (cos(TWO_PI * ratio_m_first_part))) + (0.1365995 * (cos(FOUR_PI * ratio_m_first_part))) - (0.0106411 * (cos(SIX_PI * ratio_m_first_part)));
			break;
		case FFT_WIN_TYP_BLACKMAN_HARRIS: // blackman harris
			weigh = 0.35875 - (0.48829 * (cos(TWO_PI * ratio_m_first_part))) + (0.14128 * (cos(FOUR_PI * ratio_m_first_part))) - (0.01168 * (cos(SIX_PI * ratio_m_first_part)));
			break;
		case FFT_WIN_TYP_FLT_TOP: // flat top
			weigh = 0.2810639 - (0.5208972 * cos(TWO_PI * ratio_m_first_part)) + (0.1980399 * cos(FOUR_PI * ratio_m_first_part));
			break;
		case FFT_WIN_TYP_WELCH: // welch
			weigh = 1.0 - sq((index_m_first_part - samples_m1 / 2.0) / (samples_m1 / 2.0));
			break;
		}
		if(dir == FFT_FORWARD) {
			this->_vReal[i] *= weigh;
			this->_vReal[(uint16_t)samples_m1 - i] *= weigh;
		}
		else
		{
			this->_vReal[i] /= weigh;
			this->_vReal[(uint16_t)samples_m1 - i] /= weigh;
		}
	}
}
