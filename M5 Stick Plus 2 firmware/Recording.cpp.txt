
#include "Recording.h"
#include "Globals.h"
#include "WavHelper.h"
#include "Networking.h" // for send* functions
#include "UI.h" // for displayMenu

// Вспомогательная функция для настройки микрофона
void setupMicHighGain() {
    M5.Speaker.end(); // ВАЖНО: Выключаем динамик перед использованием микрофона (общий ресурс)
    M5.Mic.end();     // Перезагружаем микрофон
    
    auto cfg = M5.Mic.config();
    
    // ИСПОЛЬЗУЕМ ГЛОБАЛЬНЫЕ НАСТРОЙКИ
    cfg.magnification = mic_gain;       
    cfg.noise_filter_level = mic_noise_level;   
    
    cfg.sample_rate = SAMPLE_RATE;
    cfg.stereo = false;           // Моно
    // cfg.task_priority = 0;     // Можно попробовать понизить приоритет если будут разрывы
    
    M5.Mic.config(cfg);
    M5.Mic.begin();
    
    // Даем время на стабилизацию
    delay(100); 
}

// Универсальная функция чтения, чтобы не дублировать код
// Возвращает true, если запись идет, false если буфер полон
bool processAudioCapture() {
    if (recorded_bytes >= RECORD_BUFFER_SIZE) {
        return false; // Буфер полон
    }

    // Рассчитываем, сколько БАЙТ осталось
    size_t bytes_remaining = RECORD_BUFFER_SIZE - recorded_bytes;
    
    // Читаем порциями. M5.Mic.record принимает КОЛИЧЕСТВО СЭМПЛОВ.
    // 1 сэмпл = 2 байта (16 бит).
    // Поэтому, если мы хотим прочитать N байт, нам нужно N/2 сэмплов.
    
    size_t chunk_samples = 1024; // Читаем по 1024 сэмпла за раз (2048 байт)
    size_t chunk_bytes = chunk_samples * sizeof(int16_t);

    // Если места мало, читаем меньше
    if (bytes_remaining < chunk_bytes) {
        chunk_bytes = bytes_remaining;
        chunk_samples = chunk_bytes / sizeof(int16_t);
    }

    if (chunk_samples > 0) {
        // rec_data + recorded_bytes - это указатель на текущую позицию в байтовом массиве
        if (M5.Mic.record(rec_data + recorded_bytes, chunk_samples, SAMPLE_RATE)) {
            recorded_bytes += chunk_bytes; // ВАЖНО: Увеличиваем на количество БАЙТ, а не сэмплов
            return true;
        }
    }
    return true; // Продолжаем, даже если record вернул false (ждем данных)
}


void handleVoiceRecording() {
    static bool isRecording = false;
    bool stopAndProcess = false;

    if (M5.BtnA.isPressed()) {
        if (!isRecording) {
            isRecording = true;
            recorded_bytes = 0;
            setupMicHighGain(); 
            M5.Lcd.fillScreen(TFT_RED);
            M5.Lcd.drawString((const char*)u8"Запись...", 60, 60); 
            Serial.println("Recording started...");
        }
        
        if (!processAudioCapture()) {
            stopAndProcess = true; // Буфер полон
        }
        
    } else if (isRecording) {
         stopAndProcess = true;
    }

    if (stopAndProcess) {
         isRecording = false;
         M5.Mic.end(); // Выключаем микрофон
         Serial.printf("Recording stopped. Total bytes: %d\n", recorded_bytes);

         if (isFirstRecording) {
             isFirstRecording = false; 
             M5.Lcd.fillScreen(TFT_BLUE);
             M5.Lcd.drawString((const char*)u8"Инициализация...", 20, 60);
             delay(1000);
             displayMenu(); 
         } else {
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Отправка...", 60, 60);

            if (recorded_bytes > 2000) { 
                uint8_t wavHeader[44];
                createWavHeader_manual(wavHeader, recorded_bytes);

                size_t total_len = sizeof(wavHeader) + recorded_bytes;
                uint8_t* wav_buffer = (uint8_t*)malloc(total_len); // Тут лучше использовать ps_malloc если возможно, но для отправки сойдет и так если влезет
                
                if (wav_buffer) {
                    memcpy(wav_buffer, wavHeader, sizeof(wavHeader));
                    memcpy(wav_buffer + sizeof(wavHeader), rec_data, recorded_bytes);
                    
                    bool success = sendRecordedVoiceHTTP(wav_buffer, total_len);
                    free(wav_buffer);
                    
                    if (success) {
                        M5.Lcd.fillScreen(TFT_GREEN);
                        M5.Lcd.drawString((const char*)u8"Отправлено!", 60, 60);
                    } else {
                        M5.Lcd.fillScreen(TFT_RED);
                        M5.Lcd.drawString((const char*)u8"Ошибка!", 80, 60);
                    }

                } else {
                    M5.Lcd.fillScreen(TFT_RED);
                    M5.Lcd.drawString((const char*)u8"Out of Memory!", 20, 60);
                }
            } else {
                M5.Lcd.fillScreen(TFT_ORANGE);
                M5.Lcd.drawString((const char*)u8"Слишком коротко", 20, 60);
            }
            delay(1500);
            setMenuMode(MODE_MAIN_MENU);
            displayMenu();
         }
    }
}

void handleGeminiRecording() {
    static bool isRecording = false;
    bool stopAndProcess = false;

    if (M5.BtnA.isPressed()) {
        if (!isRecording) {
            isRecording = true;
            recorded_bytes = 0;
            setupMicHighGain();
            M5.Lcd.fillScreen(TFT_RED);
            M5.Lcd.drawString((const char*)u8"Запрос Gemini...", 40, 60);
            Serial.println("Gemini recording started...");
        }

        if (!processAudioCapture()) {
            stopAndProcess = true;
        }

    } else if (isRecording) {
        stopAndProcess = true;
    }

    if (stopAndProcess) {
        isRecording = false;
        M5.Mic.end();
        Serial.printf("Gemini recording stopped. Total bytes: %d\n", recorded_bytes);

        if (isFirstRecording) {
            isFirstRecording = false;
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Инициализация...", 20, 60);
            delay(1000);
            setMenuMode(MODE_GEMINI_RECORDING);
            displayMenu();
        } else {
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Обработка...", 60, 60);

            if (recorded_bytes > 2000) {
                // Сохраняем копию
                if (recorded_bytes < RECORD_BUFFER_SIZE) {
                    memcpy(last_rec_data, rec_data, recorded_bytes);
                    last_recorded_bytes = recorded_bytes;
                }

                uint8_t wavHeader[44];
                createWavHeader_manual(wavHeader, recorded_bytes);

                size_t total_len = sizeof(wavHeader) + recorded_bytes;
                uint8_t* wav_buffer = (uint8_t*)malloc(total_len);
                if (wav_buffer) {
                    memcpy(wav_buffer, wavHeader, sizeof(wavHeader));
                    memcpy(wav_buffer + sizeof(wavHeader), rec_data, recorded_bytes);

                    sendVoiceToGemini(wav_buffer, total_len);
                    free(wav_buffer);
                    
                    setMenuMode(MODE_MESSAGE_STANDBY);
                    displayMenu();
                } else {
                    M5.Lcd.fillScreen(TFT_RED);
                    M5.Lcd.drawString((const char*)u8"Out of Memory!", 20, 60);
                    delay(2000);
                    setMenuMode(MODE_MAIN_MENU);
                    displayMenu();
                }
            } else {
                M5.Lcd.fillScreen(TFT_ORANGE);
                M5.Lcd.drawString((const char*)u8"Слишком коротко", 20, 60);
                delay(1500);
                setMenuMode(MODE_MAIN_MENU);
                displayMenu();
            }
        }
    }
}

void handleGoogleSearchRecording() {
    static bool isRecording = false;
    bool stopAndProcess = false;

    if (M5.BtnA.isPressed()) {
        if (!isRecording) {
            isRecording = true;
            recorded_bytes = 0;
            setupMicHighGain();
            M5.Lcd.fillScreen(TFT_RED);
            M5.Lcd.drawString((const char*)u8"Запрос Google...", 40, 60);
            Serial.println("Google Search recording started...");
        }

        if (!processAudioCapture()) {
            stopAndProcess = true;
        }

    } else if (isRecording) {
        stopAndProcess = true;
    }

    if (stopAndProcess) {
        isRecording = false;
        M5.Mic.end();
        Serial.printf("Google Search recording stopped. Total bytes: %d\n", recorded_bytes);

        if (isFirstRecording) {
            isFirstRecording = false;
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Инициализация...", 20, 60);
            delay(1000);
            setMenuMode(MODE_GOOGLE_SEARCH_RECORDING);
            displayMenu();

        } else {
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Поиск...", 60, 60);

            if (recorded_bytes > 2000) {
                if (recorded_bytes < RECORD_BUFFER_SIZE) {
                    memcpy(last_rec_data, rec_data, recorded_bytes);
                    last_recorded_bytes = recorded_bytes;
                }

                uint8_t wavHeader[44];
                createWavHeader_manual(wavHeader, recorded_bytes);

                size_t total_len = sizeof(wavHeader) + recorded_bytes;
                uint8_t* wav_buffer = (uint8_t*)malloc(total_len);
                if (wav_buffer) {
                    memcpy(wav_buffer, wavHeader, sizeof(wavHeader));
                    memcpy(wav_buffer + sizeof(wavHeader), rec_data, recorded_bytes);

                    sendVoiceToGoogleSearch(wav_buffer, total_len); 
                    free(wav_buffer);
                    
                    setMenuMode(MODE_MESSAGE_STANDBY);
                    displayMenu();

                } else {
                    M5.Lcd.fillScreen(TFT_RED);
                    M5.Lcd.drawString((const char*)u8"Out of Memory!", 20, 60);
                    delay(2000);
                    setMenuMode(MODE_MAIN_MENU);
                    displayMenu();
                }
            } else {
                M5.Lcd.fillScreen(TFT_ORANGE);
                M5.Lcd.drawString((const char*)u8"Слишком коротко", 20, 60);
                delay(1500);
                setMenuMode(MODE_MAIN_MENU);
                displayMenu();
            }
        }
    }
}

void handleGeminiFollowupRecording() {
    static bool isRecording = false;
    bool stopAndProcess = false;

    if (M5.BtnA.isPressed()) {
        if (!isRecording) {
            isRecording = true;
            recorded_bytes = 0;
            setupMicHighGain();
            M5.Lcd.fillScreen(TFT_RED);
            M5.Lcd.drawString((const char*)u8"Слушаю вопрос...", 40, 60);
            Serial.println("Gemini follow-up recording started...");
        }

        if (!processAudioCapture()) {
            stopAndProcess = true;
        }

    } else if (isRecording) {
        stopAndProcess = true;
    }

    if (stopAndProcess) {
        isRecording = false;
        M5.Mic.end();
        Serial.printf("Gemini follow-up recording stopped. Total bytes: %d\n", recorded_bytes);

        if (isFirstRecording) {
            isFirstRecording = false;
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Инициализация...", 20, 60);
            delay(1000);
            setMenuMode(MODE_GEMINI_FOLLOWUP_RECORDING);
            displayMenu();

        } else {
            M5.Lcd.fillScreen(TFT_BLUE);
            M5.Lcd.drawString((const char*)u8"Обработка...", 60, 60);

            if (recorded_bytes > 2000) {
                 if (recorded_bytes < RECORD_BUFFER_SIZE) {
                    memcpy(last_rec_data, rec_data, recorded_bytes);
                    last_recorded_bytes = recorded_bytes;
                }

                uint8_t wavHeader[44];
                createWavHeader_manual(wavHeader, recorded_bytes);

                size_t total_len = sizeof(wavHeader) + recorded_bytes;
                uint8_t* wav_buffer = (uint8_t*)malloc(total_len);
                if (wav_buffer) {
                    memcpy(wav_buffer, wavHeader, sizeof(wavHeader));
                    memcpy(wav_buffer + sizeof(wavHeader), rec_data, recorded_bytes);

                    sendFollowUpToGemini(wav_buffer, total_len, lastValidGeminiContext); 
                    free(wav_buffer);
                    
                    setMenuMode(MODE_MESSAGE_STANDBY);
                    displayMenu();
                } else {
                    M5.Lcd.fillScreen(TFT_RED);
                    M5.Lcd.drawString((const char*)u8"Out of Memory!", 20, 60);
                    delay(2000);
                    setMenuMode(MODE_MAIN_MENU);
                    displayMenu();
                }
            } else {
                M5.Lcd.fillScreen(TFT_ORANGE);
                M5.Lcd.drawString((const char*)u8"Слишком коротко", 20, 60);
                delay(1500);
                setMenuMode(MODE_MAIN_MENU);
                displayMenu();
            }
        }
    }
}
