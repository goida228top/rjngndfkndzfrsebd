# --- –°–ü–ï–†–í–ê –í–´–ü–û–õ–ù–ò–¢–ï –í –¢–ï–†–ú–ò–ù–ê–õ–ï, –ß–¢–û–ë–´ –û–°–í–û–ë–û–î–ò–¢–¨ –ü–û–†–¢ ---
# 1. sudo lsof -i :5000  (—á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ PID –ø—Ä–æ—Ü–µ—Å—Å–∞)
# 2. sudo kill -9 <PID>   (—á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å—Ç–∞—Ä—ã–π –ø—Ä–æ—Ü–µ—Å—Å)
#
# --- –î–õ–Ø –†–ê–ë–û–¢–´ GEMINI –£–°–¢–ê–ù–û–í–ò–¢–ï –ü–ï–†–ï–ú–ï–ù–ù–£–Æ –û–ö–†–£–ñ–ï–ù–ò–Ø (–û–ü–¶–ò–û–ù–ê–õ–¨–ù–û) ---
# export GEMINI_API_KEY="–í–ê–®_API_–ö–õ–Æ–ß"

import asyncio
import queue
from flask import Flask, request, jsonify
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.request import HTTPXRequest
import logging
import threading
import os
import google.generativeai as genai

# --- 0. –õ–û–ì–ò–†–û–í–ê–ù–ò–ï ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- 1. –ù–ê–°–¢–†–û–ô–ö–ò ---
TELEGRAM_BOT_TOKEN = "8269644597:AAErjQuu3b_kgH8p8MPaMWvSs1DEqUx0Dxo"
ALLOWED_CHAT_ID = 5897265978
GEMINI_MODEL_NAME = "gemini-2.5-flash-lite"

# --- 1.1 –ù–ê–°–¢–†–û–ô–ö–ò GEMINI ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
gemini_model = None  # –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è –º–æ–¥–µ–ª–∏

if not GEMINI_API_KEY:
    logger.warning("GEMINI_API_KEY environment variable not set. Using hardcoded fallback key.")
    GEMINI_API_KEY = "AIzaSyBhVdPQOUub0qkVpmr5gqCgfiLD_FxT54c" 

if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–æ–¥–µ–ª—å –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        gemini_model = genai.GenerativeModel(GEMINI_MODEL_NAME)
        logger.info(f"Gemini model '{GEMINI_MODEL_NAME}' initialized successfully.")
    except Exception as e:
        logger.error(f"Failed to configure Gemini API or initialize model: {e}")
        GEMINI_API_KEY = None # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–ª—é—á –ø—Ä–∏ –æ—à–∏–±–∫–µ
else:
    logger.warning("No Gemini API key found. Gemini features will be disabled.")


# --- 2. –ì–õ–û–ë–ê–õ–¨–ù–´–ï –û–ß–ï–†–ï–î–ò ---
text_message_queue = queue.Queue()
voice_message_queue = queue.Queue()

# --- 3. FLASK WEB SERVER (–î–õ–Ø M5STICK) ---
flask_app = Flask(__name__)

@flask_app.route('/voice', methods=['POST'])
def handle_voice():
    if request.method == 'POST':
        audio_data = request.get_data()
        if audio_data:
            logger.info(f"Received {len(audio_data)} bytes of voice data for Telegram. Queued for sending.")
            voice_message_queue.put(audio_data)
            return jsonify({"status": "ok"}), 200
    return jsonify({"status": "error"}), 400

@flask_app.route('/gemini_voice', methods=['POST'])
def handle_gemini_voice():
    if not gemini_model:
        logger.error("Gemini model not initialized, cannot process request.")
        return "Error: Gemini model not initialized on server", 503

    audio_data = request.get_data()
    if not audio_data:
        return "Error: No audio data received", 400
    
    logger.info(f"Received {len(audio_data)} bytes for Gemini processing.")
    
    try:
        # –û–ë–ù–û–í–õ–ï–ù–ù–´–ô "–£–ú–ù–´–ô" –ü–†–û–ú–ü–¢
        prompt = "–¢—ã ‚Äî –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ —É–º–Ω—ã–π –∫–∞—Ä–º–∞–Ω–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ M5Stick. –¢–≤–æ—è —Ü–µ–ª—å ‚Äî –¥–∞–≤–∞—Ç—å –ø–æ–ª–µ–∑–Ω—ã–µ, –ø–æ–ª–Ω—ã–µ, –Ω–æ –∫—Ä–∞—Ç–∫–∏–µ –æ—Ç–≤–µ—Ç—ã. –ü–†–ê–í–ò–õ–ê –û–¢–í–ï–¢–ê: 1. –°—Ç–∏–ª—å: –ë—É–¥—å –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º, –Ω–æ –≥–æ–≤–æ—Ä–∏ –ø–æ –¥–µ–ª—É. –ï—Å–ª–∏ —Ç–µ–±—è –ø—Ä–æ—Å—Ç–æ –ø–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª–∏, –æ—Ç–≤–µ—Ç—å –Ω–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∫—Ä–∞—Ç–∫–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ü—Ä–∏–≤–µ—Ç! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?'). –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ —Å—Ä–∞–∑—É –¥–∞–≤–∞–π –æ—Ç–≤–µ—Ç –ø–æ —Å—É—â–µ—Å—Ç–≤—É, –±–µ–∑ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–π. 2. –ü–æ–ª–Ω–æ—Ç–∞: –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–º. –ù–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ –≤–æ–ø—Ä–æ—Å –æ —Å–∞–º–æ–π –≤—ã—Å–æ–∫–æ–π –≥–æ—Ä–µ –†–æ—Å—Å–∏–∏, –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: '–≠–ª—å–±—Ä—É—Å - —Å–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è –≥–æ—Ä–∞ –†–æ—Å—Å–∏–∏, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –ö–∞–≤–∫–∞–∑–µ.' 3. –§–æ—Ä–º–∞—Ç: –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—Ä–æ—Å—Ç—ã–º —Ç–µ–∫—Å—Ç–æ–º, –±–µ–∑ markdown –∏–ª–∏ —Å–ø–∏—Å–∫–æ–≤. 4. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: –í –∫–æ–Ω—Ü–µ –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞, –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ' | ' –∏ —Ñ—Ä–∞–∑—É '–ó–∞–ø—Ä–æ—Å:' —Å —Ç–µ–º, –∫–∞–∫ —Ç—ã –ø–æ–Ω—è–ª –∏—Å—Ö–æ–¥–Ω—ã–π –≤–æ–ø—Ä–æ—Å. –ù–∞–ø—Ä–∏–º–µ—Ä: '... | –ó–∞–ø—Ä–æ—Å: –∫–∞–∫–∞—è —Å–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è –≥–æ—Ä–∞ –≤ –†–æ—Å—Å–∏–∏?'"
        audio_part = {'mime_type': 'audio/wav', 'data': audio_data}
        
        request_options = {"timeout": 120}
        
        # –ò–°–ü–û–õ–¨–ó–£–ï–ú –°–û–ó–î–ê–ù–ù–´–ô –†–ê–ù–ï–ï –û–ë–™–ï–ö–¢ –ú–û–î–ï–õ–ò
        response = gemini_model.generate_content(
            contents=[prompt, audio_part],
            request_options=request_options
        )
        
        logger.info("Successfully received response from Gemini.")
        return response.text, 200

    except Exception as e:
        logger.error(f"Error calling Gemini API: {e}", exc_info=True)
        return f"Error: Failed to process request with Gemini API", 500

@flask_app.route('/google_search', methods=['POST'])
def handle_google_search():
    if not gemini_model:
        logger.error("Gemini model not initialized, cannot process request.")
        return "Error: Gemini model not initialized on server", 503

    audio_data = request.get_data()
    if not audio_data:
        return "Error: No audio data received", 400
    
    logger.info(f"Received {len(audio_data)} bytes for Google Search.")
    
    try:
        prompt = "–û—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π –∑–∞–ø—Ä–æ—Å, –∏—Å–ø–æ–ª—å–∑—É—è Google –ü–æ–∏—Å–∫. –î–∞–π –ø—Ä—è–º–æ–π –∏ –∫—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç –ø–æ —Å—É—â–µ—Å—Ç–≤—É."
        audio_part = {'mime_type': 'audio/wav', 'data': audio_data}
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç Google Search
        tools = [{'google_search': {}}]
        
        request_options = {"timeout": 120}
        
        response = gemini_model.generate_content(
            contents=[prompt, audio_part],
            tools=tools,
            request_options=request_options
        )
        
        # –õ–æ–≥–∏—Ä—É–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ, –∫–∞–∫ —Ç–æ–≥–æ —Ç—Ä–µ–±—É—é—Ç –ø—Ä–∞–≤–∏–ª–∞
        try:
            if response.candidates[0].grounding_metadata:
                chunks = response.candidates[0].grounding_metadata.grounding_chunks
                urls = [chunk.web.uri for chunk in chunks if chunk.web]
                logger.info(f"Google Search sources: {urls}")
        except (AttributeError, IndexError) as e:
            logger.warning(f"Could not extract grounding metadata: {e}")

        logger.info("Successfully received response from Google Search via Gemini.")
        return response.text, 200

    except Exception as e:
        logger.error(f"Error calling Gemini API for Google Search: {e}", exc_info=True)
        return f"Error: Failed to process request with Gemini API", 500


@flask_app.route('/gemini_followup', methods=['POST'])
def handle_gemini_followup():
    if not gemini_model:
        logger.error("Gemini model not initialized, cannot process request.")
        return "Error: Gemini model not initialized on server", 503

    audio_data = request.get_data()
    previous_response = request.headers.get('X-Previous-Response')

    if not audio_data or not previous_response:
        return "Error: Missing audio data or previous response header", 400
    
    logger.info(f"Received {len(audio_data)} bytes for Gemini follow-up.")
    logger.info(f"Previous context: {previous_response}")

    try:
        # –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –ü–†–û–ú–ü–¢ –î–õ–Ø –£–¢–û–ß–ù–ï–ù–ò–Ø
        prompt = (
            "–¢—ã ‚Äî –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ —É–º–Ω—ã–π –∫–∞—Ä–º–∞–Ω–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ M5Stick. "
            "–¢–≤–æ—è —Ü–µ–ª—å ‚Äî –¥–∞–≤–∞—Ç—å –ø–æ–ª–µ–∑–Ω—ã–µ, –ø–æ–ª–Ω—ã–µ, –Ω–æ –∫—Ä–∞—Ç–∫–∏–µ –æ—Ç–≤–µ—Ç—ã. "
            "–≠—Ç–æ —É—Ç–æ—á–Ω—è—é—â–∏–π –≤–æ–ø—Ä–æ—Å. –í–µ–¥–∏ –¥–∏–∞–ª–æ–≥, –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–º –æ—Ç–≤–µ—Ç–µ.\n\n"
            "== –ü–†–ï–î–´–î–£–©–ò–ô –û–¢–í–ï–¢ ==\n"
            f"{previous_response}\n"
            "== –ö–û–ù–ï–¶ –ü–†–ï–î–´–î–£–©–ï–ì–û –û–¢–í–ï–¢–ê ==\n\n"
            "–¢–µ–ø–µ—Ä—å –æ—Ç–≤–µ—Ç—å –Ω–∞ –Ω–æ–≤—ã–π –≥–æ–ª–æ—Å–æ–≤–æ–π –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —É—á–∏—Ç—ã–≤–∞—è —ç—Ç–æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç. "
            "–ü–†–ê–í–ò–õ–ê –û–¢–í–ï–¢–ê: 1. –°—Ç–∏–ª—å: –î—Ä—É–∂–µ–ª—é–±–Ω—ã–π, –ø–æ –¥–µ–ª—É, –ø—Ä–æ–¥–æ–ª–∂–∞–π –¥–∏–∞–ª–æ–≥. "
            "2. –§–æ—Ä–º–∞—Ç: –ü—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç. 3. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: –í –∫–æ–Ω—Ü–µ –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞, –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, "
            "–¥–æ–±–∞–≤—å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ' | ' –∏ —Ñ—Ä–∞–∑—É '–ó–∞–ø—Ä–æ—Å:' —Å —Ç–µ–º, –∫–∞–∫ —Ç—ã –ø–æ–Ω—è–ª –ò–ú–ï–ù–ù–û –ü–û–°–õ–ï–î–ù–ò–ô (—É—Ç–æ—á–Ω—è—é—â–∏–π) –≤–æ–ø—Ä–æ—Å."
        )
        audio_part = {'mime_type': 'audio/wav', 'data': audio_data}
        
        request_options = {"timeout": 120}
        
        response = gemini_model.generate_content(
            contents=[prompt, audio_part],
            request_options=request_options
        )
        
        logger.info("Successfully received follow-up response from Gemini.")
        return response.text, 200

    except Exception as e:
        logger.error(f"Error calling Gemini API for follow-up: {e}", exc_info=True)
        return f"Error: Failed to process follow-up request with Gemini API", 500


@flask_app.route('/message', methods=['GET'])
def get_message():
    if not text_message_queue.empty():
        message = text_message_queue.get()
        logger.info(f"Delivering message to M5Stick: '{message}'")
        return message, 200
    else:
        return '', 204

def run_flask():
    try:
        flask_app.run(host='0.0.0.0', port=5000, threaded=True)
    except OSError as e:
        if e.errno == 98:
            logger.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            logger.error("!!! –ü–û–†–¢ 5000 –£–ñ–ï –ó–ê–ù–Ø–¢! WEB-–°–ï–†–í–ï–† –ù–ï –ó–ê–ü–£–©–ï–ù.      !!!")
            logger.error("!!! 1. –ù–∞–π–¥–∏—Ç–µ —Å—Ç–∞—Ä—ã–π –ø—Ä–æ—Ü–µ—Å—Å: sudo lsof -i :5000    !!!")
            logger.error("!!! 2. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ: sudo kill -9 <PID>            !!!")
            logger.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            os._exit(1)
        else:
            raise

# --- 4. TELEGRAM BOT ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è M5StickC. –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Ç–µ–∫—Å—Ç.")

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.chat_id != ALLOWED_CHAT_ID:
        logger.warning(f"Blocked message from unauthorized chat_id: {update.message.chat_id}")
        await update.message.reply_text("‚ùå –ò–∑–≤–∏–Ω–∏—Ç–µ, –≤—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.")
        return

    text = update.message.text
    text_message_queue.put(text)
    logger.info(f"Queued message for M5Stick: '{text}'")
    await update.message.reply_text(f"‚úÖ –í –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è M5StickC: '{text}'")

async def voice_sender_worker(app: Application) -> None:
    logger.info("Telegram voice worker started.")
    while True:
        try:
            if not voice_message_queue.empty():
                audio_data = voice_message_queue.get_nowait()
                logger.info(f"Worker processing voice message of {len(audio_data)} bytes for Telegram...")
                await app.bot.send_voice(
                    chat_id=ALLOWED_CHAT_ID,
                    voice=audio_data,
                    caption="üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å M5StickC"
                )
                logger.info("Voice message sent to Telegram successfully.")
                voice_message_queue.task_done()
            else:
                await asyncio.sleep(0.1) 
        except asyncio.CancelledError:
            logger.info("Voice worker is shutting down.")
            break
        except Exception as e:
            logger.error(f"Error sending voice message to Telegram: {e}", exc_info=True)


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error("Exception while handling an update:", exc_info=context.error)

# --- 5. –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ó–ê–ü–£–°–ö–ê –§–û–ù–û–í–´–• –ó–ê–î–ê–ß ---
async def post_init(app: Application) -> None:
    flask_thread = threading.Thread(
        target=run_flask,
        daemon=True
    )
    flask_thread.start()
    logger.info("Flask web server is starting in a background thread.")
    asyncio.create_task(voice_sender_worker(app))

# --- 6. –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ó–ê–ü–£–°–ö–ê ---
def main() -> None:
    request = HTTPXRequest(connect_timeout=10.0, read_timeout=30.0, write_timeout=60.0)
    builder = Application.builder().token(TELEGRAM_BOT_TOKEN).request(request)
    builder.post_init(post_init)
    tg_app = builder.build()

    tg_app.add_handler(CommandHandler("start", start_command))
    tg_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
    tg_app.add_error_handler(error_handler)

    logger.info("Telegram Bot is starting...")
    tg_app.run_polling()


if __name__ == '__main__':
    print("--- M5StickC Telegram & Gemini Server ---")
    if not os.environ.get("GEMINI_API_KEY"):
        print("\nINFO: GEMINI_API_KEY env var is not set, using internal fallback key.")
    if not gemini_model:
         print("\nWARNING: Gemini Model could not be initialized. The Gemini Assistant feature will not work.")
    main()